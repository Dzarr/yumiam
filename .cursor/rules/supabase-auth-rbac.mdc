---
description: Convention de gestion des rôles et permissions (RBAC) avec Supabase Auth pour une application multi-utilisateurs
globs: supabase/policies/**/*
alwaysApply: true
---

# Rule 4.2 – Gestion des rôles et accès avec Supabase Auth (supabase-auth-rbac)

## Objectif

Définir une stratégie claire de gestion des permissions utilisateurs dans Supabase en utilisant des rôles personnalisés et des politiques RLS explicites. Séparer les droits par type d'utilisateur (planner, guest, prestataire, admin) tout en gardant une architecture simple et scalable.

## Technologies concernées

- Supabase Auth
- Supabase Policies (RLS)
- PostgreSQL
- JWT / `auth.uid()`

## Principes

- Les utilisateurs sont différenciés via un champ `role` dans la table `profiles` liée à `auth.users`.
- Les rôles sont typés (`planner`, `guest`, `vendor`, `admin`) et doivent être utilisés dans toutes les policies.
- Toute table contenant des données sensibles ou liées à un utilisateur doit avoir **RLS activé par défaut**.
- Les politiques utilisent `auth.uid()` pour restreindre l'accès aux lignes où `user_id = auth.uid()`
- Aucun accès global (`select: true`) ne doit exister sans filtre précis

## Structure recommandée

```sql
-- Table profiles liée à auth.users
create table profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  role text check (role in ('planner', 'guest', 'vendor', 'admin')) not null default 'guest',
  full_name text,
  created_at timestamptz default now()
);
```

```sql
-- Exemple de policy RBAC sur guests
create policy "Planners can read their own guests"
  on guests for select
  using (
    exists (
      select 1 from profiles
      where profiles.id = auth.uid()
      and profiles.role = 'planner'
      and guests.planner_id = profiles.id
    )
  );
```

## Bonnes pratiques

- Ajouter une `view current_user_role` si besoin pour tester dynamiquement les droits dans les requêtes ou procédures
- Restreindre toutes les actions par défaut (`no access unless allowed`) et les autoriser progressivement
- Lors de l'inscription : insérer automatiquement un `profile` avec un rôle par défaut
- Ne jamais utiliser un champ `is_admin boolean` → préférer des rôles nommés + policies explicites

## Astuce sécurité

- Pour l’admin panel : utiliser un rôle JWT `role = 'admin'` injecté via un JWT custom claim (admin secret key côté backend, jamais depuis le client)

## Règle d’or

Aucun accès à une table protégée ne doit exister sans `RLS` activé et `policy` claire.  
Un utilisateur voit **uniquement** ce qui lui appartient, selon son `role`, et jamais plus.
