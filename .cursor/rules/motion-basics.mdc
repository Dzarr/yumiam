---
description: Convention d’usage des primitives Framer Motion pour les animations simples dans une interface React + Tailwind
globs: src/**/*.{tsx,jsx}
alwaysApply: true
---

# Rule 7.1 – Animations UI simples avec Framer Motion (motion-basics)

## Objectif

Standardiser l’utilisation des composants `motion` pour animer proprement les éléments d’interface (entrée, sortie, hover, clic, état), en gardant le code lisible, accessible et cohérent avec Tailwind.

## Technologies concernées

- React
- `@motion.dev/react` (Framer Motion v11+)
- TailwindCSS

---

## Prérequis

Installation :

```bash
npm install @motion.dev/react
```

---

## Principes

- Utiliser les **primitives `motion.*`** pour tout composant animé (`motion.div`, `motion.button`, etc.)
- Préférer les animations **déclaratives** (`animate`, `initial`, `exit`) plutôt que les effets impératifs
- Grouper les états dans un objet `variants` si plusieurs états existent
- Toujours définir un `transition` explicite pour lisibilité et contrôle
- Les animations doivent **complémenter l’UX**, pas la dominer

---

## Exemple – Fade in simple

```tsx
import { motion } from "@motion.dev/react";

export const Card = () => (
  <motion.div
    initial={{ opacity: 0, y: 8 }}
    animate={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.3, ease: "easeOut" }}
    className="rounded-lg bg-white p-4 shadow-md"
  >
    Contenu animé
  </motion.div>
);
```

---

## Exemple – Hover + press

```tsx
<motion.button
  whileHover={{ scale: 1.05 }}
  whileTap={{ scale: 0.95 }}
  transition={{ duration: 0.15 }}
  className="rounded bg-[--color-accent] px-4 py-2 text-white"
>
  Appuyer
</motion.button>
```

---

## Exemple – Animation conditionnelle (ex: toggle)

```tsx
{isOpen && (
  <motion.div
    initial={{ opacity: 0, scale: 0.95 }}
    animate={{ opacity: 1, scale: 1 }}
    exit={{ opacity: 0, scale: 0.95 }}
    transition={{ duration: 0.2 }}
  >
    Menu déroulant
  </motion.div>
)}
```

---

## Bonnes pratiques

- Ne jamais animer une propriété non supportée ou critique (`display`, `position`, etc.)
- Ne pas empiler les animations : un seul `motion.*` par bloc logique
- Les classes Tailwind (`transition`, `ease-in-out`, etc.) peuvent coexister, mais privilégier Framer Motion pour tout changement de `transform`, `opacity`, `scale`, etc.
- Extraire les `variants` complexes dans un fichier `motion.ts` ou dans le composant
- Nommer les blocs clairement : `motion.div` doit rester lisible (pas de logique imbriquée opaque)

---

## Accessibilité

- Respecter les préférences utilisateurs (`prefers-reduced-motion`) via :

```tsx
<motion.div
  animate={shouldReduceMotion ? {} : { opacity: 1, y: 0 }}
/>
```

- Aucune animation ne doit bloquer une action ou empêcher la navigation clavier

---

## Règle d’or

Une animation bien faite est invisible, mais elle fait sentir que l’interface est vivante.  
Si elle dérange, ralentit ou distrait, c’est qu’elle est mal conçue.