---
description: Convention de structuration des bases de données Supabase pour une application modulaire multi-rôle
globs: supabase/migrations/**/*
alwaysApply: true
---

# Rule 4.1 – Structure de la base Supabase (supabase-structure)

## Objectif

Garantir une base de données Supabase propre, modulaire et sécurisée dès le départ. Faciliter la collaboration, la scalabilité, la lecture des données, et l’écriture de politiques de sécurité claires.

## Technologies concernées

- Supabase (PostgreSQL)
- Supabase Studio (console)
- Supabase CLI (migrations)

## Principes

- Les noms de tables, colonnes, policies suivent une convention claire, en anglais, `snake_case`
- Toutes les colonnes doivent être typées explicitement et normalisées
- Chaque module ou fonctionnalité de l’app (guest, planner, table, room) possède ses propres tables dédiées
- Aucune donnée sensible ne doit être exposée en lecture sans policy explicite
- Toutes les relations doivent être clairement typées et nommées (`guest_id`, `planner_id`, etc.)
- Chaque table contient :
  - un champ `id` (UUID ou bigint) en `primary key`
  - un champ `created_at` en `timestamp with time zone`
  - un champ `updated_at` (géré via trigger si besoin)
  - un champ `user_id` ou `owner_id` si elle est liée à un compte

## Exemple de table `guests`

```sql
create table guests (
  id uuid primary key default gen_random_uuid(),
  planner_id uuid not null references planners(id) on delete cascade,
  full_name text not null,
  email text,
  has_plus_one boolean default false,
  dietary text,
  created_at timestamptz default now()
);
```

## Convention de nommage

- Tables : `guests`, `tables`, `room_assignments`, `messages`
- Colonnes : toujours en `snake_case`, descriptif mais concis (`full_name`, `has_plus_one`)
- Relations : `*_id`, toujours explicite (`planner_id`, `event_id`)
- Views et fonctions : préfixées si spécifiques (`view_table_summary`, `fn_check_conflict`)

## Bonnes pratiques

- Grouper les tables par logique métier dans les fichiers migration (`planner/`, `event/`, etc.)
- Toujours activer `row level security (RLS)` dès qu'une table est créée
- Ajouter une `policy` explicite même pour la lecture publique (éviter le mode anonyme sans contrôle)
- Documenter la structure dans un fichier `schema.md` ou un ERD exporté

## Règle d’or

Chaque table Supabase doit être :
– lisible en isolation,  
– sécurisée par défaut (RLS actif),  
– rattachée à un module ou un owner clair,  
– et ne jamais exposer de données sans policy explicite.
